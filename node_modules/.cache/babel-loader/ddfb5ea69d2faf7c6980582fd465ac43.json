{"ast":null,"code":"import _toConsumableArray from \"/home/hsn6/Desktop/scroll/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/home/hsn6/Desktop/scroll/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nvar _jsxFileName = \"/home/hsn6/Desktop/scroll/src/App.tsx\",\n    _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport { useGetSongsQuery } from \"./songs.api\";\nimport \"./styles.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar LIMIT = 10;\nexport default function App() {\n  _s();\n\n  var _this = this;\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      songs = _useState2[0],\n      setSongs = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      offset = _useState4[0],\n      setOffset = _useState4[1];\n\n  var _useGetSongsQuery = useGetSongsQuery({\n    offset: offset,\n    limit: LIMIT\n  }),\n      data = _useGetSongsQuery.data,\n      isFetching = _useGetSongsQuery.isFetching,\n      originalArgs = _useGetSongsQuery.originalArgs;\n\n  useEffect(function () {\n    if (data && originalArgs) {\n      if (songs.length !== data.total) {\n        setSongs(new Array(data.total));\n      }\n\n      setSongs(function (currentSongs) {\n        currentSongs.splice.apply(currentSongs, [originalArgs.offset, originalArgs.limit].concat(_toConsumableArray(data.list)));\n        return currentSongs;\n      });\n    }\n  }, [data]);\n\n  var onEndReached = function onEndReached() {\n    if (!isFetching && data && offset + LIMIT <= data.total) {\n      setOffset(function (currentOffset) {\n        return currentOffset += LIMIT;\n      });\n    }\n  };\n\n  var onScroll = function onScroll(event) {\n    var _ref = event.target,\n        scrollTop = _ref.scrollTop,\n        scrollHeight = _ref.scrollHeight,\n        offsetHeight = _ref.offsetHeight;\n\n    if (scrollTop + offsetHeight > scrollHeight * 0.8) {\n      onEndReached();\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: \"container\",\n    onScroll: onScroll,\n    children: [songs.filter(function (i) {\n      return i !== undefined;\n    }).map(function (song) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"item\",\n        children: song.name\n      }, song.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 11\n      }, _this);\n    }), isFetching && /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"loading\",\n      children: \"Loading...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 22\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 44,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"NBK1izzhpW/YOB0oyGEyAYEi5B4=\", false, function () {\n  return [useGetSongsQuery];\n});\n\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/home/hsn6/Desktop/scroll/src/App.tsx"],"names":["useEffect","useState","useGetSongsQuery","LIMIT","App","songs","setSongs","offset","setOffset","limit","data","isFetching","originalArgs","length","total","Array","currentSongs","splice","list","onEndReached","currentOffset","onScroll","event","target","scrollTop","scrollHeight","offsetHeight","filter","i","undefined","map","song","name","id"],"mappings":";;;;;;AAAA,SAAyBA,SAAzB,EAAoCC,QAApC,QAAoD,OAApD;AACA,SAAeC,gBAAf,QAAuC,aAAvC;AACA,OAAO,cAAP;;AAEA,IAAMC,KAAK,GAAG,EAAd;AACA,eAAe,SAASC,GAAT,GAAe;AAAA;;AAAA;;AAC5B,kBAA0BH,QAAQ,CAAuB,EAAvB,CAAlC;AAAA;AAAA,MAAOI,KAAP;AAAA,MAAcC,QAAd;;AACA,mBAA4BL,QAAQ,CAAS,CAAT,CAApC;AAAA;AAAA,MAAOM,MAAP;AAAA,MAAeC,SAAf;;AACA,0BAA2CN,gBAAgB,CAAC;AAC1DK,IAAAA,MAAM,EAANA,MAD0D;AAE1DE,IAAAA,KAAK,EAAEN;AAFmD,GAAD,CAA3D;AAAA,MAAQO,IAAR,qBAAQA,IAAR;AAAA,MAAcC,UAAd,qBAAcA,UAAd;AAAA,MAA0BC,YAA1B,qBAA0BA,YAA1B;;AAKAZ,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIU,IAAI,IAAIE,YAAZ,EAA0B;AACxB,UAAIP,KAAK,CAACQ,MAAN,KAAiBH,IAAI,CAACI,KAA1B,EAAiC;AAC/BR,QAAAA,QAAQ,CAAC,IAAIS,KAAJ,CAAUL,IAAI,CAACI,KAAf,CAAD,CAAR;AACD;;AACDR,MAAAA,QAAQ,CAAC,UAACU,YAAD,EAAkB;AACzBA,QAAAA,YAAY,CAACC,MAAb,OAAAD,YAAY,GACVJ,YAAY,CAACL,MADH,EAEVK,YAAY,CAACH,KAFH,4BAGPC,IAAI,CAACQ,IAHE,GAAZ;AAKA,eAAOF,YAAP;AACD,OAPO,CAAR;AAQD;AACF,GAdQ,EAcN,CAACN,IAAD,CAdM,CAAT;;AAgBA,MAAMS,YAAY,GAAG,SAAfA,YAAe,GAAM;AACzB,QAAI,CAACR,UAAD,IAAeD,IAAf,IAAuBH,MAAM,GAAGJ,KAAT,IAAkBO,IAAI,CAACI,KAAlD,EAAyD;AACvDN,MAAAA,SAAS,CAAC,UAACY,aAAD;AAAA,eAAoBA,aAAa,IAAIjB,KAArC;AAAA,OAAD,CAAT;AACD;AACF,GAJD;;AAMA,MAAMkB,QAAwC,GAAG,SAA3CA,QAA2C,CAACC,KAAD,EAAW;AAC1D,eAAkDA,KAAK,CAACC,MAAxD;AAAA,QAAQC,SAAR,QAAQA,SAAR;AAAA,QAAmBC,YAAnB,QAAmBA,YAAnB;AAAA,QAAiCC,YAAjC,QAAiCA,YAAjC;;AACA,QAAIF,SAAS,GAAGE,YAAZ,GAA2BD,YAAY,GAAG,GAA9C,EAAmD;AACjDN,MAAAA,YAAY;AACb;AACF,GALD;;AAOA,sBACE;AAAK,IAAA,EAAE,EAAE,WAAT;AAAsB,IAAA,QAAQ,EAAEE,QAAhC;AAAA,eACGhB,KAAK,CACHsB,MADF,CACS,UAACC,CAAD,EAAO;AACb,aAAOA,CAAC,KAAKC,SAAb;AACD,KAHF,EAIEC,GAJF,CAIM,UAACC,IAAD;AAAA,0BACH;AAAoB,QAAA,SAAS,EAAE,MAA/B;AAAA,kBACGA,IAAI,CAAEC;AADT,SAAUD,IAAI,CAAEE,EAAhB;AAAA;AAAA;AAAA;AAAA,eADG;AAAA,KAJN,CADH,EAUGtB,UAAU,iBAAI;AAAK,MAAA,EAAE,EAAE,SAAT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAVjB;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAcD;;GAnDuBP,G;UAGqBF,gB;;;KAHrBE,G","sourcesContent":["import { UIEventHandler, useEffect, useState } from \"react\";\nimport { Song, useGetSongsQuery } from \"./songs.api\";\nimport \"./styles.css\";\n\nconst LIMIT = 10;\nexport default function App() {\n  const [songs, setSongs] = useState<(Song | undefined)[]>([]);\n  const [offset, setOffset] = useState<number>(0);\n  const { data, isFetching, originalArgs } = useGetSongsQuery({\n    offset,\n    limit: LIMIT\n  });\n\n  useEffect(() => {\n    if (data && originalArgs) {\n      if (songs.length !== data.total) {\n        setSongs(new Array(data.total));\n      }\n      setSongs((currentSongs) => {\n        currentSongs.splice(\n          originalArgs.offset,\n          originalArgs.limit,\n          ...data.list\n        );\n        return currentSongs;\n      });\n    }\n  }, [data]);\n\n  const onEndReached = () => {\n    if (!isFetching && data && offset + LIMIT <= data.total) {\n      setOffset((currentOffset) => (currentOffset += LIMIT));\n    }\n  };\n\n  const onScroll: UIEventHandler<HTMLDivElement> = (event) => {\n    const { scrollTop, scrollHeight, offsetHeight } = event.target as any;\n    if (scrollTop + offsetHeight > scrollHeight * 0.8) {\n      onEndReached();\n    }\n  };\n\n  return (\n    <div id={\"container\"} onScroll={onScroll}>\n      {songs\n        .filter((i) => {\n          return i !== undefined;\n        })\n        .map((song) => (\n          <div key={song!.id} className={\"item\"}>\n            {song!.name}\n          </div>\n        ))}\n      {isFetching && <div id={\"loading\"}>Loading...</div>}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}